\subsubsection{Analizar efectos del filtro y cambios propuestos}
Para la implementación del circuito se utilizó un \textbf{Timer} que genera la señal de referencia de forma periódica (figura~\ref{fig:esqPsoc}), almacenando su estado en un registro. De esta manera, también es posible observar el estado lógico de la referencia a través del pin digital \textbf{ref}.  

Durante la práctica no se disponía de resistencias de \SI{75}{k\ohm}, por lo que se reemplazaron por un valor cercano de \SI{82}{k\ohm}. Si bien el polo generado no presenta una variación significativa, los parámetros de sintonía $K_p$, $T_i$ y $T_d$ sí se ven afectados de manera considerable, como se mostrará más adelante.


\insertarfigura{./img/Circuito1.png}{Circuito Esquemático utilizado en el Psoc}{fig:esqPsoc}{1}
\onecolumn

\paragraph{Código implementado en el PSoC}\hfill \break

\begin{lstlisting}[style=cstyle,caption={Código completo del PSoC},label={lst:c}]
#include "project.h"
#include <stdio.h>

#define ref_max 3.0f
#define ref_min 2.0f
double ref = ref_min;
double e = 0.0;
double e_1 = 0.0;
double e_2 = 0.0;
double u = 0.0;
double u_unsat = 0.0;
double u_sat = 0.0;
double u_1 = 0.0;
double u_2 = 0.0;
double offset = 2.5f; 
uint8 dac_value=0;

volatile uint8 flag_5seg = 0;  // Bandera para 5 segundos
static uint16 counter = 0;
CY_ISR_PROTO(Adquisicion);

// ISR del Timer (5 segundos)
uint8 flag = '0';
float muestra;
#define T (double)(1.0/100.0)
#define Ts T
#define Kp (double) 0.5//4.1
#define Ti (double)0.015//0.01
#define Td (double)0.005//0.003

CY_ISR_PROTO(Adquisicion){
	//static uint16_t contador = 0;
	
	flag = '1';
	ref = (Status_Reg_1_Read()) ? ref_max : ref_min;
	isr_1_ClearPending();

}

int main(void) {
	uint32 num = counter;
	char buffer[10];
	//uint8 i = 0;
	
	CyGlobalIntEnable;
	
	// Inicializar componentes
	
	//UART_Start();           // Iniciar UART
	Opamp_1_Start();
	Opamp_2_Start();
	Opamp_3_Start();
	ADC_SAR_1_Start();
	VDAC8_1_Start();
	Clock_1_Start();
	isr_1_StartEx(Adquisicion);
	
	isr_1_Enable();
	Timer_1_Start();
	
	//float Kp = 0.5;//4.1;
	
	//float Td = 0.0003;//0.0001;
	//float Ti = 0.01;//0.0115;
	int16 aux=0;
	VDAC8_1_SetValue(128u);
	for(;;) {
		
		if (flag == '1'){
			
			//Cuando se recibe una "I" por el puerto serial
			//Se inicializa una nueva adquisición de datos
			flag = '0'; 
			//Se habilita la digitalización y la INT 1   
			
			muestra =ADC_SAR_1_CountsTo_Volts(ADC_SAR_1_GetResult16());
			// muestra=muestra-2.0;
			e = ref - muestra; //se calcula el error
			
			//se calcula el esfuerzo de control con la ecuacion en diferencia del compensador
			
			
			u =  u_1 + Kp*(((1+(Ts/Ti) + (Td/Ts))*e)  - (1 +(2*Td/Ts))*e_1 + (Td/Ts)*e_2)  ; 
			
			dac_value = (uint8)((u / 4.0f) * 255.0f);
			
			VDAC8_1_SetValue(dac_value);           
			
			u_1 = u;
			u_2 = u_1;
			e_2 = e_1;
			e_1 = e;
			
			isr_1_Enable();
		}
		
	}
}
	
\end{lstlisting}
\twocolumn
\paragraph{Resultados Osciloscopio}
En primer lugar, se simuló el \textbf{textbook} utilizando dos frecuencias diferentes: \SI{100}{\hertz} y \SI{300}{\hertz}.

\insertarfigura{./img/textbook100.jpg}{Implementación a \SI{100}{\hertz}}{fig:imp100}{1}
\insertarfigura{./img/textbook300.jpg}{Implementación a \SI{300}{\hertz}}{fig:imp300}{1}

\insertarfigura{./img/sinAstrom.jpg}{Implementación sin Astr\"om}{fig:impsas}{1}
\insertarfigura{./img/sinAstrom1.jpg}{Implementación sin Astr\"om}{fig:impsas1}{1}

\onecolumn
\paragraph{Modificación del código para la implementación del método de Astr\"om}
Se añadieron las siguientes constantes \texttt{define}: \hfill \break

\begin{lstlisting}[style=cstyle,caption={Definiciones adicionales para implementar Astr\"om},label={lst:c1}]
	#define ud_max (double)4.08*0.9
	#define ud_min (double)4.08*0.1
	#define int_max (double)255
	#define int_min (double)0
	#define m (double)(int_max-int_min)/(ud_max-ud_min)
	
	
	#define N 8
	#define alpha2  (double)Td*Ti/(T*T)
	#define alpha1  (double)N*Ti/T
	#define beta2   (double)Kp*(N*Td*Ti + Td*Ti)/(T*T)
	#define beta1   (double)Kp*(N*Ti + Td)/T
	#define beta0   (double)Kp*N
	
	#define U0  (double)(alpha2 + alpha1)
	#define U1  (double)(-(2*alpha2 + alpha1))
	#define U2  (double)(alpha2)
	
	#define E0  (double)(beta2 + beta1 + beta0)
	#define E1  (double)(-1*(2*beta2 + beta1))
	#define E2  (double)(beta2)
	
\end{lstlisting}

Posteriormente, se modificó el \texttt{main} del código~\ref{lst:c} para implementar el siguiente algoritmo:

\begin{lstlisting}[style=cstyle,caption={Implementación del algoritmo de Aström con saturación},label={lst:c1}]
u_unsat = (-U1*u_1 + -U2*u_2 + E0*e + E1*e_1 + E2*e_2)/U0;
if (u_unsat > ud_max) u = ud_max;
else if (u_unsat < ud_min) u = ud_min;
else u = u_unsat;

\end{lstlisting}

\twocolumn
\insertarfigura{./img/sinsat300.jpg}{Implementación sin Saturar a \SI{300}{\hertz}, con Astr\"om}{fig:sinsat300}{1}
\insertarfigura{./img/sat300.jpg}{Implementación Saturarando a \SI{300}{\hertz}, con Astr\"om}{fig:sat300}{1}