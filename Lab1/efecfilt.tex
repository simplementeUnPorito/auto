\subsubsection{Analizar efectos del filtro y cambios propuestos}
Para la implementación del circuito se utilizó un \textbf{Timer} que genera la señal de referencia de forma periódica (figura~\ref{fig:esqPsoc}), almacenando su estado en un registro. De esta manera, también es posible observar el estado lógico de la referencia a través del pin digital \textbf{ref}.  

Durante la práctica no se disponía de resistencias de \SI{75}{k\ohm}, por lo que se reemplazaron por un valor cercano de \SI{82}{k\ohm}. Si bien el polo generado no presenta una variación significativa, los parámetros de sintonía $K_p$, $T_i$ y $T_d$ sí se ven afectados de manera considerable, como se mostrará más adelante.


\insertarfigura{./img/Circuito1.png}{Circuito Esquemático utilizado en el Psoc}{fig:esqPsoc}{1}
\onecolumn

\paragraph{Código implementado en el PSoC}\hfill \break

\begin{lstlisting}[style=cstyle,caption={Código completo del PSoC},label={lst:c}]
#include "project.h"
#include <stdio.h>

#define ref_max 3.0f
#define ref_min 2.0f
double ref = ref_min;
double e = 0.0;
double e_1 = 0.0;
double e_2 = 0.0;
double u = 0.0;
double u_unsat = 0.0;
double u_sat = 0.0;
double u_1 = 0.0;
double u_2 = 0.0;
double offset = 2.5f; 
uint8 dac_value=0;

volatile uint8 flag_5seg = 0;  // Bandera para 5 segundos
static uint16 counter = 0;
CY_ISR_PROTO(Adquisicion);

// ISR del Timer (5 segundos)
uint8 flag = '0';
float muestra;
#define T (double)(1.0/100.0)
#define Ts T
#define Kp (double) 0.5//4.1
#define Ti (double)0.015//0.01
#define Td (double)0.005//0.003

CY_ISR_PROTO(Adquisicion){
	//static uint16_t contador = 0;
	
	flag = '1';
	ref = (Status_Reg_1_Read()) ? ref_max : ref_min;
	isr_1_ClearPending();

}

int main(void) {
	uint32 num = counter;
	char buffer[10];
	//uint8 i = 0;
	
	CyGlobalIntEnable;
	
	// Inicializar componentes
	
	//UART_Start();           // Iniciar UART
	Opamp_1_Start();
	Opamp_2_Start();
	Opamp_3_Start();
	ADC_SAR_1_Start();
	VDAC8_1_Start();
	Clock_1_Start();
	isr_1_StartEx(Adquisicion);
	
	isr_1_Enable();
	Timer_1_Start();
	
	//float Kp = 0.5;//4.1;
	
	//float Td = 0.0003;//0.0001;
	//float Ti = 0.01;//0.0115;
	int16 aux=0;
	VDAC8_1_SetValue(128u);
	for(;;) {
		
		if (flag == '1'){
			
			//Cuando se recibe una "I" por el puerto serial
			//Se inicializa una nueva adquisición de datos
			flag = '0'; 
			//Se habilita la digitalización y la INT 1   
			
			muestra =ADC_SAR_1_CountsTo_Volts(ADC_SAR_1_GetResult16());
			// muestra=muestra-2.0;
			e = ref - muestra; //se calcula el error
			
			//se calcula el esfuerzo de control con la ecuacion en diferencia del compensador
			
			
			u =  u_1 + Kp*(((1+(Ts/Ti) + (Td/Ts))*e)  - (1 +(2*Td/Ts))*e_1 + (Td/Ts)*e_2)  ; 
			
			dac_value = (uint8)((u / 4.0f) * 255.0f);
			
			VDAC8_1_SetValue(dac_value);           
			
			u_1 = u;
			u_2 = u_1;
			e_2 = e_1;
			e_1 = e;
			
			isr_1_Enable();
		}
		
	}
}
	
\end{lstlisting}
\twocolumn
\paragraph{Resultados Osciloscopio}
En primer lugar, se realizó la experiencia práctica con el \textbf{textbook}, utilizando dos frecuencias diferentes: \SI{100}{\hertz} y \SI{300}{\hertz}.
\insertarfigura{./img/textbook100.jpg}{Implementación a \SI{100}{\hertz}}{fig:imp100}{1}



\insertarfigura{./img/textbook300.jpg}{Implementación a \SI{300}{\hertz}}{fig:imp300}{1}

En la figura~\ref{fig:imp100} y~\ref{fig:imp300}, se observan las señales \textbf{cían} que será la \textit{referencia}, \textbf{magenta} el cual es el \textit{esfuerzo de control} y la señal \textbf{amarilla} es la \textit{señal de salida}. \hfill \break
La implementación práctica con el circuito textbook demuestra que, a \SI{100}{\hertz} (figura~\ref{fig:imp100}), el PID logra un buen seguimiento de la referencia, mientras que a \SI{300}{\hertz} (figura~\ref{fig:imp300}) la respuesta de la salida se ve muy atenuada, lo que evidencia las limitaciones dinámicas del sistema. Cabe destacar que, aunque a \SI{100}{\hertz} la respuesta parezca adecuada, esta frecuencia es aproximadamente diez veces mayor que el ancho de banda del sistema, mientras que a \SI{300}{\hertz} es treinta veces mayor. En consecuencia, la salida aparenta seguir la referencia de muy bien, pero al aumentar la referencia se hace evidente la incapacidad del sistema para responder correctamente.

Luego se hizo la experiencia práctica con saturaci\'on y sin saturaci\'on, ambos sin Astr\"om:
\insertarfigura{./img/sinAstrom.jpg}{Implementación sin saturaci\'on}{fig:satsina}{1}
\insertarfigura{./img/sinAstrom1.jpg}{Implementación con saturaci\'on}{fig:sinsatsina}{1}

En la figura~\ref{fig:satsina} y~\ref{fig:sinsatsina}, se observan las señales \textbf{cían} que será la \textit{referencia}, \textbf{magenta} el cual es el \textit{esfuerzo de control} y la señal \textbf{amarilla} es la \textit{señal de salida}. \hfill \break
Antes de implementar el método de Aström, se evaluó el circuito a \SI{300}{\hertz} con y sin saturación. 
\textbf{Con saturación}, el esfuerzo de control se recorta en los límites, lo que incrementa el error y atenúa aún más la salida. 
\textbf{Sin saturación}, el esfuerzo alcanza picos mayores y la respuesta mejora levemente; sin embargo, la frecuencia de referencia permanece muy por encima del ancho de banda del sistema, por lo que el seguimiento sigue siendo deficiente. 
Estos resultados reflejan que la principal limitación es dinámica (banda de paso) y que la saturación agrava el desempeño, además de introducir riesgo de \emph{windup} del integrador. \hfill \break

\onecolumn
\paragraph{Modificación del código para la implementación del método de Astr\"om}
Se añadieron las siguientes constantes \texttt{define}: \hfill \break

\begin{lstlisting}[style=cstyle,caption={Definiciones adicionales para implementar Astr\"om},label={lst:c1}]
	#define ud_max (double)4.08*0.9
	#define ud_min (double)4.08*0.1
	#define int_max (double)255
	#define int_min (double)0
	#define m (double)(int_max-int_min)/(ud_max-ud_min)
	
	
	#define N 8
	#define alpha2  (double)Td*Ti/(T*T)
	#define alpha1  (double)N*Ti/T
	#define beta2   (double)Kp*(N*Td*Ti + Td*Ti)/(T*T)
	#define beta1   (double)Kp*(N*Ti + Td)/T
	#define beta0   (double)Kp*N
	
	#define U0  (double)(alpha2 + alpha1)
	#define U1  (double)(-(2*alpha2 + alpha1))
	#define U2  (double)(alpha2)
	
	#define E0  (double)(beta2 + beta1 + beta0)
	#define E1  (double)(-1*(2*beta2 + beta1))
	#define E2  (double)(beta2)
	
\end{lstlisting}

Posteriormente, se modificó el \texttt{main} del código~\ref{lst:c} para implementar el siguiente algoritmo:

\begin{lstlisting}[style=cstyle,caption={Implementación del algoritmo de Aström con saturación},label={lst:c1}]
u_unsat = (-U1*u_1 + -U2*u_2 + E0*e + E1*e_1 + E2*e_2)/U0;
if (u_unsat > ud_max) u = ud_max;
else if (u_unsat < ud_min) u = ud_min;
else u = u_unsat;

\end{lstlisting}

\twocolumn

Posteriormente, se realizó la experiencia práctica con y sin saturación, en ambos casos utilizando el método de Astr\"om.
\insertarfigura{./img/sinsat300.jpg}{Implementación sin Saturar a \SI{300}{\hertz}, con Astr\"om}{fig:sinsat300}{1}
\insertarfigura{./img/sat300.jpg}{Implementación Saturarando a \SI{300}{\hertz}, con Astr\"om}{fig:sat300}{1}

En la figura~\ref{fig:sinsat300} y~\ref{fig:sat300}, se observan las señales \textbf{cían} que será la \textit{referencia},la señal \textbf{amarilla} es la \textit{señal de salida} y \textbf{magenta} el cual es el \textit{esfuerzo de control}. \hfill \break





