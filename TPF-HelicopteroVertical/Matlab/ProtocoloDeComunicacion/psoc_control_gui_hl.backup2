function psoc_control_gui_hl()
% GUI basada en UARTP High-Level API.
%
% Requiere en el path:
%   uartp_open, uartp_reset, uartp_setmode, uartp_send_coeffs, uartp_get_coeffs,
%   uartp_init, uartp_stop, uartp_make_tf, uartp_make_ss
%
% Streaming:
%   El PSoC manda frames binarios de 8 bytes: [u(float32) y(float32)] little-endian
%   cada N muestras (según c15).
%
% Nota:
%   El streaming reader es un timer que solo lee múltiplos de 8 bytes y,
%   si encuentra basura, descarta hasta realinear (buffer simple).

    timerClockHz = 1.491e6;

    S = struct();
    S.sp = [];
    S.isConnected = false;

    % --- Streaming state ---
    S.streamTimer  = [];
    S.t0           = [];            % (no usado para eje X, lo dejo)
    S.nVec         = zeros(0,1);     % eje X: n samples (frames)
    S.uVec         = zeros(0,1);
    S.yVec         = zeros(0,1);
    S.maxPoints    = 4000;
    S.streamRxBuf  = uint8([]);     % buffer para resincronizar
    S.framesTotal  = 0;             % contador global de frames parseados

    % --- NEW: control de parseo ---
    S.streamParseEnabled = true;    % si false: descarta UART y NO parsea frames

    % --------------------
    % UI
    % --------------------
    fig = uifigure( ...
        'Name', sprintf('PSoC Control GUI (UARTP HL) | TimerClk=%.0f Hz', timerClockHz), ...
        'Position', [80 80 1280 720] ...
    );
    fig.CloseRequestFcn = @onClose;

    % Plot
    ax = uiaxes(fig, 'Position', [20 220 820 480]);
    ax.XGrid = 'on';
    ax.YGrid = 'on';
    title(ax, 'Streaming u,y');
    xlabel(ax, 'n (samples)');
    ylabel(ax, 'value');

    hold(ax, 'on');
    hU = stairs(ax, nan, nan, 'DisplayName', 'u');  % u con stairs
    hY = plot(ax,   nan, nan, 'DisplayName', 'y');
    legend(ax, 'show', 'Location', 'best');
    hold(ax, 'off');

    % Log
    txtLog = uitextarea(fig, 'Editable', 'off', 'Position', [20 20 820 180]);
    txtLog.Value = strings(0,1);

    % --------------------
    % Connection panel
    % --------------------
    pConn = uipanel(fig, 'Title', 'Connection', 'Position', [860 610 400 90]);

    uilabel(pConn, 'Text', 'COM:', 'Position', [10 35 35 22]);
    edtCom = uieditfield(pConn, 'text', 'Value', 'COM9', 'Position', [50 35 90 22]);

    edtBaud = uieditfield( ...
        pConn, 'numeric', 'Value', 115200, 'Limits', [1200 2000000], ...
        'Position', [150 35 90 22] ...
    );
    uilabel(pConn, 'Text', 'baud', 'Position', [245 35 40 22]);

    btnConnect = uibutton( ...
        pConn, 'Text', 'Connect', 'Position', [10 5 90 24], ...
        'ButtonPushedFcn', @onConnectToggle ...
    );

    lblStat = uilabel(pConn, 'Text', 'DISCONNECTED', 'Position', [110 5 280 24]);

    btnReset = uibutton( ...
        pConn, 'Text', 'Reset (r)', 'Position', [310 5 80 24], ...
        'ButtonPushedFcn', @onReset ...
    );

    % --------------------
    % Mode panel
    % --------------------
    pMode = uipanel(fig, 'Title', 'Mode', 'Position', [860 430 400 170]);

    ddType = uidropdown( ...
        pMode, 'Items', {'TF','SS','Open-loop'}, ...
        'Position', [10 120 120 24], ...
        'ValueChangedFcn', @(~,~) refreshVisibility() ...
    );

    ddObserver = uidropdown( ...
        pMode, 'Items', {'Predictor','Actual'}, ...
        'Position', [150 120 120 24], ...
        'Tooltip', 'Only applies for SS' ...
    );

    cbIntegrator = uicheckbox(pMode, 'Text', 'Integrator', 'Position', [290 120 110 24]);

    % --- N ---
    uilabel(pMode, 'Text', 'N', 'Position', [10 85 20 24]);
    edtN = uieditfield( ...
        pMode, 'numeric', 'Limits', [0 100000], 'RoundFractionalValues', 'on', ...
        'Value', 20, 'Position', [35 85 80 24] ...
    );

    % --- Fs (Hz) ---
    uilabel(pMode, 'Text', 'Fs (Hz)', 'Position', [130 85 50 24]);
    edtFs = uieditfield( ...
        pMode, 'numeric', 'Limits', [0.001 1e9], ...
        'Value', double(timerClockHz)/1500.0, ...
        'Position', [180 85 90 24], ...
        'ValueChangedFcn', @onFsChanged ...
    );

    % --- Computed Period ---
    lblPeriod = uilabel(pMode, 'Text', 'Period=1500 counts', 'Position', [10 60 260 20]);

    btnSendMode = uibutton( ...
        pMode, 'Text', 'Send Mode (m)', 'Position', [280 85 110 24], ...
        'ButtonPushedFcn', @onSendMode ...
    );

    btnSendCoeffs = uibutton( ...
        pMode, 'Text', 'Send Coeffs (c)', 'Position', [10 25 140 28], ...
        'ButtonPushedFcn', @onSendCoeffs ...
    );

    cbVerify = uicheckbox( ...
        pMode, 'Text', 'Verify (t)', 'Value', true, 'Position', [160 30 120 24] ...
    );

    btnGetCoeffs = uibutton( ...
        pMode, 'Text', 'Get Coeffs (t)', 'Position', [280 25 110 28], ...
        'ButtonPushedFcn', @onGetCoeffs ...
    );

    % --------------------
    % Control panel
    % --------------------
    pRef = uipanel(fig, 'Title', 'Control', 'Position', [860 320 400 100]);

    uilabel(pRef, 'Text', 'u0 / ref', 'Position', [10 45 60 22]);
    edtU0 = uieditfield(pRef, 'numeric', 'Value', 0.25, 'Position', [80 40 100 26]);

    btnStart = uibutton( ...
        pRef, 'Text', 'Start (i)', 'Position', [200 40 90 26], ...
        'ButtonPushedFcn', @onStart ...
    );

    btnStop = uibutton( ...
        pRef, 'Text', 'Stop (s)', 'Position', [300 40 80 26], ...
        'ButtonPushedFcn', @onStop ...
    );

    cbWaitBack = uicheckbox( ...
        pRef, 'Text', 'wait back to COMMAND', 'Value', true, ...
        'Position', [10 10 200 24] ...
    );

    % --------------------
    % TF panel
    % --------------------
    pTF = uipanel(fig, 'Title', 'TF Coeffs', 'Position', [860 20 400 280]);

    uilabel(pTF, 'Text', 'Numerator b0..b5', 'Position', [10 235 200 18]);
    bEdt = gobjects(1,6);
    for i = 1:6
        bEdt(i) = uieditfield(pTF, 'text', 'Value', '0', 'Position', [10+63*(i-1) 210 60 22]);
    end

    uilabel(pTF, 'Text', 'Denominator a0..a5', 'Position', [10 175 200 18]);
    aEdt = gobjects(1,6);
    for i = 1:6
        aEdt(i) = uieditfield(pTF, 'text', 'Value', '0', 'Position', [10+63*(i-1) 150 60 22]);
    end
    aEdt(1).Value = '1';

    uilabel(pTF, 'Text', 'Reserved (c13..c16)', 'Position', [10 115 140 18]);
    edtC13 = uieditfield(pTF, 'numeric', 'Value', 0, 'Position', [10 90 80 22]);
    edtC14 = uieditfield(pTF, 'numeric', 'Value', 0, 'Position', [100 90 80 22]);
    uilabel(pTF, 'Text', 'c15=N, c16=Period', 'Position', [190 90 200 22]);

    % --------------------
    % SS panel
    % --------------------
    pSS = uipanel(fig, 'Title', 'SS Coeffs (2 estados)', 'Position', [860 20 400 280]);

    % A(2x2)
    uilabel(pSS, 'Text', 'A (2x2)', 'Position', [10 235 60 18]);
    edtA11 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [70 232 55 22]);
    edtA12 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [130 232 55 22]);
    edtA21 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [70 205 55 22]);
    edtA22 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [130 205 55 22]);

    % B(2)
    uilabel(pSS, 'Text', 'B (2)', 'Position', [200 235 40 18]);
    edtB1 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [240 232 55 22]);
    edtB2 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [300 232 55 22]);

    % C(2)
    uilabel(pSS, 'Text', 'C (2)', 'Position', [200 205 40 18]);
    edtC1 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [240 202 55 22]);
    edtC2 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [300 202 55 22]);

    % D
    uilabel(pSS, 'Text', 'D', 'Position', [10 175 20 18]);
    edtD = uieditfield(pSS, 'text', 'Value', '0', 'Position', [35 172 55 22]);

    % L(2)
    uilabel(pSS, 'Text', 'L (2)', 'Position', [100 175 40 18]);
    edtL1 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [140 172 55 22]);
    edtL2 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [200 172 55 22]);

    % K(2)
    uilabel(pSS, 'Text', 'K (2)', 'Position', [10 145 40 18]);
    edtK1 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [50 142 55 22]);
    edtK2 = uieditfield(pSS, 'text', 'Value', '0', 'Position', [110 142 55 22]);

    % Ki
    uilabel(pSS, 'Text', 'Ki', 'Position', [200 145 20 18]);
    edtKi = uieditfield(pSS, 'text', 'Value', '0', 'Position', [225 142 60 22]);

    % init UI state
    onFsChanged();
    refreshVisibility();

    % =====================================================================
    % Callbacks
    % =====================================================================
    function refreshVisibility()
        typ = ddType.Value;
        pTF.Visible = strcmp(typ, 'TF');
        pSS.Visible = strcmp(typ, 'SS');

        ddObserver.Enable   = strcmp(typ, 'SS');
        cbIntegrator.Enable = strcmp(typ, 'SS');

        btnSendCoeffs.Enable = true;
    end

    function onFsChanged(~,~)
        try
            fs = double(edtFs.Value);
            if ~isfinite(fs) || fs <= 0
                lblPeriod.Text = "Period=? counts (Fs inválida)";
                return;
            end
            per = computePeriodCounts(fs);
            lblPeriod.Text = sprintf("Period=%d counts (Fs=%.6g Hz)", per, fs);
        catch
            lblPeriod.Text = "Period=? counts";
        end
    end

    function onConnectToggle(~,~)
        if ~S.isConnected
            com = strtrim(string(edtCom.Value));
            if com == ""
                logMsg("COM vacío.");
                return;
            end
            try
                S.sp = uartp_open(com, edtBaud.Value);
                S.isConnected = true;
                btnConnect.Text = "Disconnect";
                lblStat.Text = "CONNECTED: " + com;

                % limpieza
                try flush(S.sp); catch, end

                % al conectar, habilitamos parseo y streaming
                S.streamParseEnabled = true;
                S.streamRxBuf = uint8([]);

                logMsg("Connected to " + com);
                startStreaming();
            catch e
                logMsg("Connect error: " + string(e.message));
                stopStreaming();
            end
        else
            try
                stopStreaming();
                if ~isempty(S.sp)
                    try flush(S.sp); catch, end
                    clear S.sp;
                end
            catch
            end
            S.sp = [];
            S.isConnected = false;
            btnConnect.Text = "Connect";
            lblStat.Text = "DISCONNECTED";
            logMsg("Disconnected.");
        end
    end

    function onReset(~,~)
        if ~requireConn(); return; end
        try
            stopStreaming();
            try flush(S.sp); catch, end
            uartp_reset(S.sp);
            try flush(S.sp); catch, end

            % luego de reset, el stream puede arrancar en cualquier estado:
            % habilitamos parseo solo cuando el usuario dé Start (más seguro),
            % pero igual dejamos el timer leyendo para no acumular bytes.
            S.streamParseEnabled = false;
            S.streamRxBuf = uint8([]);

            startStreaming();
            logMsg("reset OK (parsing disabled until Start)");
        catch e
            logMsg("reset FAIL: " + string(e.message));
            startStreaming();
        end
    end

    function onSendMode(~,~)
        if ~requireConn(); return; end
        try
            stopStreaming();
            try flush(S.sp); catch, end

            mode = computeMode();
            uartp_setmode(S.sp, mode);

            try flush(S.sp); catch, end

            % En COMMAND pueden entrar bytes ASCII -> no parsear frames.
            % Rehabilitamos parseo al Start.
            S.streamParseEnabled = false;
            S.streamRxBuf = uint8([]);

            startStreaming();
            logMsg(sprintf("setmode OK: mode=%d (%s) (parsing disabled until Start)", mode, ddType.Value));
        catch e
            logMsg("setmode FAIL: " + string(e.message));
            startStreaming();
        end
    end

    function onSendCoeffs(~,~)
        if ~requireConn(); return; end
        typ = ddType.Value;

        try
            stopStreaming();
            try flush(S.sp); catch, end

            Nval = single(round(double(edtN.Value)));

            fs = double(edtFs.Value);
            if ~isfinite(fs) || fs <= 0
                error("Fs inválida (Hz).");
            end
            PeriodCounts = single(computePeriodCounts(fs));

            if strcmp(typ, 'TF')
                b = parse6(bEdt, 'b');
                a = parse6(aEdt, 'a');
                coeffs = uartp_make_tf(b, a);

                coeffs(13) = single(edtC13.Value);
                coeffs(14) = single(edtC14.Value);
                coeffs(15) = Nval;
                coeffs(16) = PeriodCounts;

            elseif strcmp(typ, 'SS')
                A = [ ...
                    parse1(edtA11, 'A11'), parse1(edtA12, 'A12'); ...
                    parse1(edtA21, 'A21'), parse1(edtA22, 'A22')  ...
                ];
                B  = [parse1(edtB1, 'B1'); parse1(edtB2, 'B2')];
                C  = [parse1(edtC1, 'C1'); parse1(edtC2, 'C2')].';
                D  = parse1(edtD,  'D');
                L  = [parse1(edtL1, 'L1'); parse1(edtL2, 'L2')];
                K  = [parse1(edtK1, 'K1'); parse1(edtK2, 'K2')];
                Ki = parse1(edtKi, 'Ki');

                coeffs = uartp_make_ss(A, B, C, D, L, K, Ki);
                coeffs(15) = Nval;
                coeffs(16) = PeriodCounts;

            else
                coeffs = zeros(16,1,'single');
                coeffs(15) = Nval;
                coeffs(16) = PeriodCounts;
            end

            uartp_send_coeffs(S.sp, coeffs, cbVerify.Value);

            try flush(S.sp); catch, end

            % Tras enviar coeffs, aún estamos en COMMAND -> no parsear.
            S.streamParseEnabled = false;
            S.streamRxBuf = uint8([]);

            startStreaming();

            logMsg(sprintf( ...
                "coeffs OK (%s) N=%g Fs=%.6g Hz Period=%g counts (parsing disabled until Start)", ...
                typ, double(Nval), fs, double(PeriodCounts) ...
            ));
        catch e
            logMsg("coeffs FAIL: " + string(e.message));
            startStreaming();
        end
    end

    function onGetCoeffs(~,~)
        if ~requireConn(); return; end

        try
            stopStreaming();
            try flush(S.sp); catch, end

            c = uartp_get_coeffs(S.sp);
            c = single(c(:));
            typ = ddType.Value;

            if strcmp(typ,'TF')
                num6 = c(1:6).';
                den6 = c(7:12).';
                res13 = c(13);
                res14 = c(14);
                N = c(15);
                Period = c(16);
                fs = periodToFs(double(Period));

                logMsg("t OK (TF)");
                logMsg(" num6 = " + vecfmt(num6));
                logMsg(" den6 = " + vecfmt(den6));
                logMsg(sprintf( ...
                    " meta: res13=%g res14=%g N=%g Period=%g counts Fs≈%.6g Hz", ...
                    double(res13), double(res14), double(N), double(Period), fs ...
                ));

            elseif strcmp(typ,'SS')
                A = [c(1) c(2); c(3) c(4)];
                B = [c(5); c(6)];
                Cv = [c(7) c(8)];
                D = c(9);
                L = [c(10); c(11)];
                K = [c(12); c(13)];
                Ki = c(14);
                N = c(15);
                Period = c(16);
                fs = periodToFs(double(Period));

                logMsg("t OK (SS)");
                logMsg(" A = " + matfmt(A));
                logMsg(" B = " + vecfmt(B.'));
                logMsg(" C = " + vecfmt(Cv));
                logMsg(sprintf(" D = %g", double(D)));
                logMsg(" L = " + vecfmt(L.'));
                logMsg(" K = " + vecfmt(K.'));
                logMsg(sprintf(" Ki = %g", double(Ki)));
                logMsg(sprintf( ...
                    " meta: N=%g Period=%g counts Fs≈%.6g Hz", ...
                    double(N), double(Period), fs ...
                ));

            else
                N = c(15);
                Period = c(16);
                fs = periodToFs(double(Period));

                logMsg("t OK (Open-loop / raw).");
                logMsg(sprintf( ...
                    " meta: N=%g Period=%g counts Fs≈%.6g Hz", ...
                    double(N), double(Period), fs ...
                ));
            end

            try flush(S.sp); catch, end

            % seguimos en COMMAND -> no parsear frames
            S.streamParseEnabled = false;
            S.streamRxBuf = uint8([]);

            startStreaming();

        catch e
            logMsg("t FAIL: " + string(e.message));
            startStreaming();
        end
    end

    function onStart(~,~)
        if ~requireConn(); return; end
        try
            stopStreaming();
            try flush(S.sp); catch, end

            u0 = double(edtU0.Value);
            uartp_init(S.sp, u0);

            % Al arrancar CONTROL: habilitar parseo de frames
            S.streamParseEnabled = true;

            % limpiar buffer de re-sync (pero NO borrar el gráfico)
            S.streamRxBuf = uint8([]);

            try flush(S.sp); catch, end
            startStreaming();

            logMsg(sprintf("init OK: u0/ref=%.6g (CONTROL) (parsing enabled)", u0));
        catch e
            logMsg("init FAIL: " + string(e.message));
            S.streamParseEnabled = true; % si falla, igual dejamos listo para el próximo intento
            startStreaming();
        end
    end

    function onStop(~,~)
        if ~requireConn(); return; end
        try
            % STOP: deshabilitar parseo (descartar bytes numéricos/ASCII)
            S.streamParseEnabled = false;

            stopStreaming();
            try flush(S.sp); catch, end

            uartp_stop(S.sp, cbWaitBack.Value);

            % limpiar cualquier basura pendiente
            try flush(S.sp); catch, end
            S.streamRxBuf = uint8([]);

            % Importante: NO reactivar streaming parseable acá.
            % Igual dejamos el timer corriendo para drenar, pero descartando.
            startStreaming();

            logMsg("stop OK (parsing disabled; UART bytes discarded)");
        catch e
            logMsg("stop FAIL: " + string(e.message));
            S.streamParseEnabled = false;
            stopStreaming();
        end
    end

    % =====================================================================
    % Helpers
    % =====================================================================
    function ok = requireConn()
        ok = S.isConnected && ~isempty(S.sp);
        if ~ok
            logMsg("Not connected.");
        end
    end

    function logMsg(msg)
        ts = string(datestr(now,'HH:MM:SS.FFF'));
        line = "[" + ts + "] " + string(msg);

        v = txtLog.Value;
        if ~isstring(v), v = string(v); end

        v(end+1,1) = line;
        if numel(v) > 400
            v = v(end-400:end);
        end

        txtLog.Value = v;
        drawnow limitrate;
    end

    function mode = computeMode()
        typ = ddType.Value;

        if strcmp(typ,'TF')
            mode = 0;
            return;
        end
        if strcmp(typ,'Open-loop')
            mode = 5;
            return;
        end

        isAct = strcmp(ddObserver.Value,'Actual');
        hasI  = cbIntegrator.Value;

        if ~isAct && ~hasI
            mode = 1;
        elseif isAct && ~hasI
            mode = 2;
        elseif ~isAct && hasI
            mode = 3;
        else
            mode = 4;
        end
    end

    function per = computePeriodCounts(fsHz)
        per = round(double(timerClockHz) / double(fsHz) / 2);

        if ~isfinite(per) || per < 1
            per = 1;
        end
        if per > 2^31-1
            per = 2^31-1;
        end
    end

    function fs = periodToFs(periodCounts)
        if ~isfinite(periodCounts) || periodCounts <= 0
            fs = NaN;
        else
            fs = double(timerClockHz) / double(periodCounts) / 2;
        end
    end

    function v = parse6(edts, name)
        v = zeros(1,6);
        for kk = 1:6
            v(kk) = parse1(edts(kk), sprintf("%s[%d]", name, kk-1));
        end
    end

    function v = parse1(edt, name)
        s = strtrim(string(edt.Value));
        if s == ""
            uialert(fig, "Campo vacío: " + name, 'Input error');
            error("Campo vacío: %s", name);
        end

        v = str2double(s);
        if ~isfinite(v)
            uialert(fig, "Número inválido en " + name + ": '" + s + "'", 'Input error');
            error("Número inválido: %s", name);
        end
    end

    function s = vecfmt(x)
        x = double(x(:).');
        s = "[" + strjoin(string(x), " ") + "]";
    end

    function s = matfmt(M)
        M = double(M);
        s = sprintf("[[%g %g]; [%g %g]]", M(1,1), M(1,2), M(2,1), M(2,2));
        s = string(s);
    end

    % =====================================================================
    % Streaming (nested)
    % =====================================================================
    function startStreaming()
        stopStreaming();  % por si ya estaba

        if ~S.isConnected || isempty(S.sp)
            return;
        end

        if isempty(S.t0)
            S.t0 = tic; %#ok<NASGU>
        end

        S.streamTimer = timer( ...
            'ExecutionMode', 'fixedSpacing', ...
            'Period', 0.02, ...
            'TimerFcn', @onStreamTick, ...
            'BusyMode', 'drop' ...
        );
        start(S.streamTimer);

        if S.streamParseEnabled
            logMsg("Streaming reader ON (parsing ENABLED) (frames 8B: u,y)");
        else
            logMsg("Streaming reader ON (parsing DISABLED) (discarding UART bytes)");
        end
    end

    function stopStreaming()
        try
            if ~isempty(S.streamTimer) && isvalid(S.streamTimer)
                stop(S.streamTimer);
                delete(S.streamTimer);
            end
        catch
        end
        S.streamTimer = [];
    end

    function onStreamTick(~,~)
        if ~S.isConnected || isempty(S.sp)
            return;
        end

        sp = S.sp;

        try
            nAvail = sp.NumBytesAvailable;
            if nAvail <= 0
                return;
            end

            raw = read(sp, nAvail, "uint8");
            if isempty(raw)
                return;
            end

            % Si parseo está deshabilitado (COMMAND/STOP), descartamos TODO lo que venga.
            if ~S.streamParseEnabled
                % importante: no acumular nada que desalineé
                S.streamRxBuf = uint8([]);
                return;
            end

            % Parseo habilitado: acumulamos y procesamos frames
            S.streamRxBuf = [S.streamRxBuf; uint8(raw(:))];

            n = numel(S.streamRxBuf);
            nFrames = floor(n/8);
            if nFrames <= 0
                return;
            end

            take = 8*nFrames;
            blk = S.streamRxBuf(1:take);
            S.streamRxBuf = S.streamRxBuf(take+1:end);

            frames = reshape(blk, 8, []).';   % nFrames x 8

            % Parse little endian float32
            u_u32 = uint32(frames(:,1)) ...
                + bitshift(uint32(frames(:,2)), 8) ...
                + bitshift(uint32(frames(:,3)),16) ...
                + bitshift(uint32(frames(:,4)),24);

            y_u32 = uint32(frames(:,5)) ...
                + bitshift(uint32(frames(:,6)), 8) ...
                + bitshift(uint32(frames(:,7)),16) ...
                + bitshift(uint32(frames(:,8)),24);

            u = typecast(u_u32, 'single');
            y = typecast(y_u32, 'single');

            % eje X por contador de frames
            idx0 = S.framesTotal;
            nIdx = (idx0 + (1:numel(u))).';

            S.nVec = [S.nVec; nIdx];
            S.uVec = [S.uVec; double(u)];
            S.yVec = [S.yVec; double(y)];

            if numel(S.nVec) > S.maxPoints
                k0 = numel(S.nVec) - S.maxPoints + 1;
                S.nVec = S.nVec(k0:end);
                S.uVec = S.uVec(k0:end);
                S.yVec = S.yVec(k0:end);
            end

            set(hU, 'XData', S.nVec, 'YData', S.uVec);
            set(hY, 'XData', S.nVec, 'YData', S.yVec);

            S.framesTotal = S.framesTotal + numel(u);

            if mod(S.framesTotal, 50) == 0
                logMsg(sprintf( ...
                    "stream: framesTotal=%d (último u=%.4g y=%.4g)", ...
                    S.framesTotal, S.uVec(end), S.yVec(end) ...
                ));
            end

            drawnow limitrate;

        catch e
            S.streamRxBuf = uint8([]);
            try flush(sp); catch, end
            logMsg("stream WARN: " + string(e.message));
        end
    end

    function onClose(~,~)
        try
            stopStreaming();
            if S.isConnected && ~isempty(S.sp)
                try flush(S.sp); catch, end
                clear S.sp;
            end
        catch
        end
        delete(fig);
    end

end