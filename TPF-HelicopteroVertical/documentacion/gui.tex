% ============================================================
\subsection{Interfaz gráfica de usuario}
\label{ap:gui_matlab}
% ============================================================

\begin{lstlisting}[language=Matlab,caption={Interfaz Gráfica de Usuario},label={lst:gui_matlab}]
function psoc_control_gui_hl_v3()
% PSoC Control GUI - UARTP single-file (NO external functions)
% Compatible con uartp_sw.c / uartp_sw.h (handshake eco-confirmado por word 4B).
%
% Protocolo (COMMAND):
%   cmd 'm' -> device: 'R' -> host sends 4B payload (mode + padding) eco/ACK -> device: 'K'
%   cmd 'c' -> device: 'R' -> host sends 100B payload (25 floats) eco/ACK -> device: 'K'
%   cmd 't' -> device: 'S' -> device sends 100B payload eco/ACK -> device: 'K'
%   cmd 'i' -> device: 'R' -> host sends 4B float32 eco/ACK -> device: 'K' then device entra CONTROL
%   cmd 's' -> device: 'K' (COMMAND)  / en CONTROL lo maneja ISR y responde 'K'
%   cmd 'r' -> device: 'K' y reset
%
% Telemetría CONTROL:
%   frames 8B: [u(float32) y(float32)] little-endian

% =========================
% Estado
% =========================
S = struct();
S.sp = [];
S.isConnected = false;

% Streaming
S.streamTimer  = [];
S.streamRxBuf  = uint8([]);
S.streamParseEnabled = false; % OFF hasta Start
S.nVec         = zeros(0,1);
S.uVec         = zeros(0,1);
S.yVec         = zeros(0,1);
S.framesTotal  = 0;
S.maxPoints    = 400000;
S.inTxn        = false;

% Auto-stop
S.autoStopEnabled   = false;
S.autoStopTarget    = 0;
S.autoStopArmed     = false;
S.autoStopStartBase = 0;
S.autoStopPending   = false;
S.autoStopReason    = "";

% Plot scaling
S.scaleU = 0.01;
S.scaleY = 1.0;

% ===== Debug =====
DBG_LOG_BYTES   = true;      % loguea RX/TX de comandos/payload
DBG_HEX_DUMP    = true;      % muestra hex de payloads (corto)
DBG_PRINT_COEFFS= true;      % imprime el vector de 25 floats

% ===== Protocolo fijo =====
TF_MAX_ORDER = 10;

% índices meta (MATLAB 1-based para arrays)
IDX_TF_ORDER = 23; % c23 (0-based 22)
IDX_META_N   = 24; % c24 (0-based 23)
IDX_META_FS  = 25; % c25 (0-based 24)

% ===== Constantes LL (debe coincidir con C) =====
RSP_READY_RX = uint8('R');
RSP_READY_TX = uint8('S');
RSP_OK       = uint8('K');
RSP_ERR      = uint8('!'); %#ok<NASGU>

CTL_ACK      = uint8('A');
CTL_NAK      = uint8('N');

STEP_TIMEOUT_S   = 0.5;      % ~500ms por step (PSoC usa ~300ms)
MAX_WORD_RETRIES = 50;       % igual que firmware

% =========================
% UI
% =========================
fig = uifigure('Name','PSoC Control GUI (UARTP single-file)','Position',[80 80 1280 720]);
fig.CloseRequestFcn = @onClose;

ax = uiaxes(fig, 'Position', [20 220 820 480]);
ax.XGrid = 'on'; ax.YGrid = 'on';
title(ax,'Streaming u,y');
xlabel(ax,'frame index'); ylabel(ax,'value');
hold(ax,'on');
hU = stairs(ax, nan, nan, 'DisplayName','u');
hY = plot(ax,   nan, nan, 'DisplayName','y');
legend(ax,'show','Location','best');
hold(ax,'off');

txtLog = uitextarea(fig,'Editable','off','Position',[20 20 820 180]);
txtLog.Value = strings(0,1);

RX = 860; RW = 400;

% Connection
pConn = uipanel(fig,'Title','Connection','Position',[RX 620 RW 95]);
uilabel(pConn,'Text','COM:','Position',[10 45 35 22]);
edtCom = uieditfield(pConn,'text','Value','COM19','Position',[50 45 90 22]);

edtBaud = uieditfield(pConn,'numeric','Value',115200,'Limits',[1200 2000000],'Position',[150 45 90 22]);
uilabel(pConn,'Text','baud','Position',[245 45 40 22]);

btnConnect = uibutton(pConn,'Text','Connect','Position',[10 10 90 26],'ButtonPushedFcn',@onConnectToggle);
lblStat = uilabel(pConn,'Text','DISCONNECTED','Position',[110 10 280 26]);

btnReset = uibutton(pConn,'Text','Reset (r)','Position',[310 10 80 26],'ButtonPushedFcn',@onReset);

% Mode
pMode = uipanel(fig,'Title','Mode','Position',[RX 435 RW 180]);

ddType = uidropdown(pMode,'Items',{'TF','SS','Open-loop'},'Value','Open-loop', ...
'Position',[10 130 120 24],'ValueChangedFcn',@(~,~)refreshVisibility());

ddObserver = uidropdown(pMode,'Items',{'Predictor','Actual'},'Position',[150 130 120 24]);
cbIntegrator = uicheckbox(pMode,'Text','Integrator','Position',[290 130 110 24]);

uilabel(pMode,'Text','N','Position',[10 95 20 24]);
edtN = uieditfield(pMode,'numeric','Limits',[0 1e9],'RoundFractionalValues','on','Value',1,'Position',[35 95 80 24]);

uilabel(pMode,'Text','Fs (Hz)','Position',[130 95 50 24]);
edtFs = uieditfield(pMode,'numeric','Limits',[0.001 1e9],'Value',1000,'Position',[180 95 90 24], ...
'ValueChangedFcn',@(~,~)onFsChanged());

lblFs = uilabel(pMode,'Text','Fs=?','Position',[10 70 360 20]);

btnSendMode   = uibutton(pMode,'Text','Send Mode (m)','Position',[280 95 110 24],'ButtonPushedFcn',@onSendMode);
btnSendCoeffs = uibutton(pMode,'Text','Send Coeffs (c)','Position',[10 25 140 30],'ButtonPushedFcn',@onSendCoeffs);
cbVerify      = uicheckbox(pMode,'Text','Verify (t)','Value',true,'Position',[160 30 120 24]);
btnGetCoeffs  = uibutton(pMode,'Text','Get Coeffs (t)','Position',[280 25 110 30],'ButtonPushedFcn',@onGetCoeffs);

% Control
pRef = uipanel(fig,'Title','Control','Position',[RX 315 RW 110]);
uilabel(pRef,'Text','u0 / ref','Position',[10 55 60 22]);
edtU0 = uieditfield(pRef,'numeric','Value',1000,'Position',[80 50 80 26]);

uilabel(pRef,'Text','r x','Position',[165 55 25 22]);
edtRmult = uieditfield(pRef,'numeric','Value',1.0,'Limits',[-1e12 1e12],'Position',[190 50 55 26]);

btnStart = uibutton(pRef,'Text','Start (i)','Position',[250 50 70 26],'ButtonPushedFcn',@onStart);
btnStop  = uibutton(pRef,'Text','Stop (s)','Position',[325 50 65 26],'ButtonPushedFcn',@onStop);

cbWaitBack = uicheckbox(pRef,'Text','wait back to COMMAND','Value',true,'Position',[10 15 190 24]); %#ok<NASGU>

cbAutoStop = uicheckbox(pRef,'Text','Auto-stop','Value',false,'Position',[205 15 75 24]);
uilabel(pRef,'Text','at frames','Position',[285 15 55 22]);
edtAutoStopN = uieditfield(pRef,'numeric','Limits',[0 1e12],'RoundFractionalValues','on','Value',0,'Position',[345 15 45 24]);

% Data
pData = uipanel(fig,'Title','Data','Position',[RX 5 RW 85]);
btnExportMAT = uibutton(pData,'Text','Export .mat','Position',[10 12 120 32],'ButtonPushedFcn',@onExportMAT);
btnClearData = uibutton(pData,'Text','Clear data','Position',[140 12 120 32],'ButtonPushedFcn',@onClearData);

lblDataInfo = uilabel(pData,'Text','n=0','Position',[70 64 80 22],'HorizontalAlignment','right');

uilabel(pData,'Text','u x','Position',[270 20 30 18]);
edtScaleU = uieditfield(pData,'numeric','Value',S.scaleU,'Limits',[-1e12 1e12],'Position',[300 17 70 22], ...
'ValueChangedFcn',@(~,~)onScaleChanged());

uilabel(pData,'Text','y x','Position',[375 20 30 18]);
edtScaleY = uieditfield(pData,'numeric','Value',S.scaleY,'Limits',[-1e12 1e12],'Position',[405 17 70 22], ...
'ValueChangedFcn',@(~,~)onScaleChanged());

% TF panel
pTF = uipanel(fig,'Title','TF (25): b0..b10, a0..a10, order, N, Fs','Position',[RX 90 RW 220]);
uilabel(pTF,'Text','k','Position',[10 175 20 18]);
uilabel(pTF,'Text','b(k)','Position',[60 175 60 18]);
uilabel(pTF,'Text','a(k)','Position',[185 175 60 18]);

tfData = zeros(TF_MAX_ORDER+1,2);
tfData(1,2) = 1; % a0
tfTable = uitable(pTF,'Data',tfData,'ColumnName',{'b','a'},'RowName',string(0:TF_MAX_ORDER), ...
'ColumnEditable',[true true],'Position',[10 50 260 125]);

uilabel(pTF,'Text','Order (0..10)','Position',[285 145 100 18]);
edtTFOrder = uieditfield(pTF,'numeric','Value',5,'Limits',[0 TF_MAX_ORDER], ...
'RoundFractionalValues','on','Position',[285 120 80 24]);

% SS panel (3 estados)
pSS = uipanel(fig,'Title','SS (3 estados / 25)','Position',[RX 90 RW 220]);

yLblTop = 170; y1=145; y2=120; y3=95; yLblMid=80; yMid=55; yK1=55; yK2=30; yK3=5;
uilabel(pSS,'Text','A (3x3)','Position',[10 yLblTop 60 18]);
edtA11 = uieditfield(pSS,'text','Value','1','Position',[10  y1 60 22]);
edtA12 = uieditfield(pSS,'text','Value','0','Position',[75  y1 60 22]);
edtA13 = uieditfield(pSS,'text','Value','0','Position',[140 y1 60 22]);
edtA21 = uieditfield(pSS,'text','Value','0','Position',[10  y2 60 22]);
edtA22 = uieditfield(pSS,'text','Value','1','Position',[75  y2 60 22]);
edtA23 = uieditfield(pSS,'text','Value','0','Position',[140 y2 60 22]);
edtA31 = uieditfield(pSS,'text','Value','0','Position',[10  y3 60 22]);
edtA32 = uieditfield(pSS,'text','Value','0','Position',[75  y3 60 22]);
edtA33 = uieditfield(pSS,'text','Value','1','Position',[140 y3 60 22]);

uilabel(pSS,'Text','B (3x1)','Position',[210 yLblTop 60 18]);
edtB1 = uieditfield(pSS,'text','Value','0','Position',[210 y1 60 22]);
edtB2 = uieditfield(pSS,'text','Value','0','Position',[210 y2 60 22]);
edtB3 = uieditfield(pSS,'text','Value','1','Position',[210 y3 60 22]);

uilabel(pSS,'Text','L (3x1)','Position',[280 yLblTop 60 18]);
edtL1 = uieditfield(pSS,'text','Value','0','Position',[280 y1 60 22]);
edtL2 = uieditfield(pSS,'text','Value','0','Position',[280 y2 60 22]);
edtL3 = uieditfield(pSS,'text','Value','0','Position',[280 y3 60 22]);

uilabel(pSS,'Text','C (1x3)','Position',[10 yLblMid 60 18]);
edtC1 = uieditfield(pSS,'text','Value','1','Position',[10  yMid 60 22]);
edtC2 = uieditfield(pSS,'text','Value','0','Position',[75  yMid 60 22]);
edtC3 = uieditfield(pSS,'text','Value','0','Position',[140 yMid 60 22]);

uilabel(pSS,'Text','D','Position',[210 yLblMid 30 18]);
edtD  = uieditfield(pSS,'text','Value','0','Position',[210 yMid 60 22]);

uilabel(pSS,'Text','Ki','Position',[210 yK2 30 18]);
edtKi = uieditfield(pSS,'text','Value','0','Position',[210 yK3 60 22]);

uilabel(pSS,'Text','K (3x1)','Position',[280 yLblMid 60 18]);
edtK1 = uieditfield(pSS,'text','Value','0','Position',[280 yK1 60 22]);
edtK2 = uieditfield(pSS,'text','Value','0','Position',[280 yK2 60 22]);
edtK3 = uieditfield(pSS,'text','Value','0','Position',[280 yK3 60 22]);

% init visuals
onFsChanged();
refreshVisibility();
updateDataInfo();
applyPlotScaling();

% =========================
% Helpers UI
% =========================
function logMsg(msg)
ts = string(datestr(now,'HH:MM:SS.FFF'));
line = "[" + ts + "] " + string(msg);
v = txtLog.Value; if ~isstring(v), v = string(v); end
v(end+1,1) = line;
if numel(v) > 600, v = v(end-600:end); end
txtLog.Value = v;
drawnow limitrate;
end

function ok = requireConn()
ok = S.isConnected && ~isempty(S.sp);
if ~ok, logMsg("Not connected."); end
end

function refreshVisibility()
typ = ddType.Value;
pTF.Visible = strcmp(typ,'TF');
pSS.Visible = strcmp(typ,'SS');
ddObserver.Enable   = strcmp(typ,'SS');
cbIntegrator.Enable = strcmp(typ,'SS');
end

function onFsChanged()
try
fs = double(edtFs.Value);
if ~isfinite(fs) || fs <= 0
lblFs.Text = "Fs inválida";
else
lblFs.Text = sprintf("Fs=%.6g Hz", fs);
end
catch
lblFs.Text = "Fs=?";
end
end

function updateDataInfo()
try, lblDataInfo.Text = sprintf("n=%d", numel(S.nVec)); catch, end
end

function onScaleChanged()
su = double(edtScaleU.Value);
sy = double(edtScaleY.Value);
if ~isfinite(su) || su==0, su=1; end
if ~isfinite(sy) || sy==0, sy=1; end
S.scaleU = su; S.scaleY = sy;
applyPlotScaling();
drawnow limitrate;
end

function applyPlotScaling()
su = double(S.scaleU); if ~isfinite(su) || su==0, su=1; end
sy = double(S.scaleY); if ~isfinite(sy) || sy==0, sy=1; end

if isempty(S.nVec)
set(hU,'XData',nan,'YData',nan);
set(hY,'XData',nan,'YData',nan);
else
set(hU,'XData',S.nVec,'YData',S.uVec*su);
set(hY,'XData',S.nVec,'YData',S.yVec*sy);
end
end

function setInTxnFalse()
S.inTxn = false;
end

% =========================
% Mode encoding
% =========================
function mode = computeMode()
typ = ddType.Value;
if strcmp(typ,'TF'), mode = 0; return; end
if strcmp(typ,'Open-loop'), mode = 5; return; end

isAct = strcmp(ddObserver.Value,'Actual');
hasI  = cbIntegrator.Value;

if ~isAct && ~hasI, mode = 1;
elseif isAct && ~hasI, mode = 2;
elseif ~isAct && hasI, mode = 3;
else, mode = 4;
end
end

function ord = getTFOrder()
ord = round(double(edtTFOrder.Value));
if ~isfinite(ord), ord = 5; end
ord = max(0, min(TF_MAX_ORDER, ord));
end

function [b,a] = readTFTable()
D = tfTable.Data;
if iscell(D)
D2 = nan(size(D));
for ii=1:size(D,1)
for jj=1:size(D,2)
v = D{ii,jj};
if isstring(v) || ischar(v)
x = str2double(strtrim(string(v)));
else
x = double(v);
end
D2(ii,jj) = x;
end
end
D = D2;
else
D = double(D);
end
if any(~isfinite(D),'all'), error("TF table: NaN/Inf o texto inválido."); end
b = D(:,1).'; a = D(:,2).';
end

% =========================
% UARTP LL (matching uartp_sw.c)
% =========================
function ll_flush()
if isempty(S.sp), return; end
try flush(S.sp); catch, end
end

function b = ll_readexact(n, timeout_s)
if nargin<2, timeout_s = STEP_TIMEOUT_S; end
t0 = tic;
buf = zeros(1,n,'uint8');
k = 0;
while k < n
if toc(t0) > timeout_s
error("Timeout leyendo %d bytes (tengo %d)", n, k);
end
avail = S.sp.NumBytesAvailable;
if avail > 0
m = min(avail, n-k);
tmp = read(S.sp, m, "uint8");
buf(k+1:k+m) = tmp(:);
k = k + m;
else
pause(0.001);
end
end
b = buf(:);
end

function rsp = ll_cmd_wait(cmd_char, timeout_s)
if nargin<2, timeout_s = STEP_TIMEOUT_S; end
valid = uint8(['R','S','K','!']);

tx = uint8(cmd_char);
write(S.sp, tx, "uint8");
logBytes("TX CMD", tx);

t0 = tic;
while true
if toc(t0) > timeout_s
error("Timeout esperando respuesta a '%s'", char(cmd_char));
end
if S.sp.NumBytesAvailable > 0
bb = read(S.sp, 1, "uint8"); bb = bb(1);
logBytes("RX RSP1", bb);
if any(bb == valid)
rsp = bb;
return;
end
else
pause(0.001);
end
end
end

% wrapper (seguridad)
function ll_send_payload(payload_u8) %#ok<DEFNU>
ll_send_payload2(payload_u8);
end

function ll_send_payload2(payload_u8)
payload_u8 = uint8(payload_u8(:));
logBytes("TX PAYLOAD", payload_u8);

n = numel(payload_u8);
idx = 1;

while idx <= n
w = uint8([0;0;0;0]);
take = min(4, n-idx+1);
w(1:take) = payload_u8(idx:idx+take-1);

tries = 0;
while true
tries = tries + 1;
if tries > MAX_WORD_RETRIES
error("Demasiados reintentos enviando word en idx=%d", idx);
end

write(S.sp, w, "uint8");

echo  = ll_readexact(4, STEP_TIMEOUT_S);
match = isequal(echo(:), w(:));

if match, write(S.sp, CTL_ACK, "uint8");
else,     write(S.sp, CTL_NAK, "uint8");
end

conf = ll_readexact(1, STEP_TIMEOUT_S); conf = conf(1);

if match && conf == CTL_ACK
break;
end
end

idx = idx + take;
end
end

function payload = ll_recv_payload2(nbytes)
payload = zeros(nbytes,1,'uint8');
off = 0;

while off < nbytes
rem = nbytes - off;
store = min(4, rem);

tries = 0;
while true
tries = tries + 1;
if tries > MAX_WORD_RETRIES
error("Demasiados reintentos recibiendo word (off=%d)", off);
end

w = ll_readexact(4, STEP_TIMEOUT_S);
write(S.sp, w, "uint8"); % eco

ctl = ll_readexact(1, STEP_TIMEOUT_S); ctl = ctl(1);

if ctl == CTL_ACK
payload(off+1:off+store) = w(1:store);
write(S.sp, CTL_ACK, "uint8");
off = off + store;
break;
else
write(S.sp, CTL_NAK, "uint8");
end
end
end

logBytes("RX PAYLOAD", payload);
end

function payload_u8 = ll_to_payload_bytes(coeffs)
if isa(coeffs,'uint8')
payload_u8 = coeffs(:);
assert(mod(numel(payload_u8),4)==0, "payload uint8 debe ser múltiplo de 4 bytes");
return;
end
c = single(coeffs(:));
payload_u8 = typecast(c,'uint8');
payload_u8 = payload_u8(:);
end

% =========================
% UARTP HL commands (local)
% =========================
function uartp_setmode_local(mode)
ll_flush();
rsp = ll_cmd_wait('m', STEP_TIMEOUT_S);
if rsp ~= RSP_READY_RX
error("m no devolvió R (rsp=%c)", char(rsp));
end
raw = uint8([mode;0;0;0]); % 4 bytes
ll_send_payload2(raw);
final = ll_readexact(1, STEP_TIMEOUT_S); final = final(1);
if final ~= RSP_OK
error("m no terminó con K (rsp=%c)", char(final));
end
end

function uartp_send_coeffs_local(coeffs25, verify_roundtrip)
if nargin<2, verify_roundtrip = true; end
ll_flush();
rsp = ll_cmd_wait('c', STEP_TIMEOUT_S);
if rsp ~= RSP_READY_RX
error("c no devolvió R (rsp=%c)", char(rsp));
end
payload = ll_to_payload_bytes(coeffs25);
if numel(payload) ~= 100
error("coeffs deben ser 25 floats => 100 bytes (tengo %d)", numel(payload));
end
ll_send_payload2(payload);
final = ll_readexact(1, STEP_TIMEOUT_S); final = final(1);
if final ~= RSP_OK
error("c no terminó con K (rsp=%c)", char(final));
end

if verify_roundtrip
rx = uartp_get_coeffs_raw_local();
if ~isequal(rx(:), payload(:))
error("Roundtrip 't' devolvió bytes distintos");
end
end
end

function rx = uartp_get_coeffs_raw_local()
ll_flush();
rsp = ll_cmd_wait('t', STEP_TIMEOUT_S);
if rsp ~= RSP_READY_TX
error("t no devolvió S (rsp=%c)", char(rsp));
end
rx = ll_recv_payload2(100); % 100 bytes = 25 floats
final = ll_readexact(1, STEP_TIMEOUT_S); final = final(1);
if final ~= RSP_OK
error("t no terminó con K (rsp=%c)", char(final));
end
end

function uartp_init_local(r_float)
ll_flush();
rsp = ll_cmd_wait('i', STEP_TIMEOUT_S);
if rsp ~= RSP_READY_RX
error("i no devolvió R (rsp=%c)", char(rsp));
end
payload = typecast(single(r_float),'uint8'); payload = payload(:);
ll_send_payload2(payload);
final = ll_readexact(1, STEP_TIMEOUT_S); final = final(1);
if final ~= RSP_OK
error("i no terminó con K (rsp=%c)", char(final));
end
end

function uartp_stop_local()
ll_flush();
rsp = ll_cmd_wait('s', STEP_TIMEOUT_S);
if rsp ~= RSP_OK
error("s no devolvió K (rsp=%c)", char(rsp));
end
end

function uartp_reset_local()
ll_flush();
rsp = ll_cmd_wait('r', STEP_TIMEOUT_S);
if rsp ~= RSP_OK
error("r no devolvió K (rsp=%c)", char(rsp));
end
end

% =========================
% Packets: TF25 / SS25 (3 estados)
% =========================
function coeffs = make_tf25(b, a, order, N, FsHz)
b = double(b(:).'); a = double(a(:).');
order = round(double(order));
order = max(0, min(TF_MAX_ORDER, order));

bb = zeros(1,TF_MAX_ORDER+1);
aa = zeros(1,TF_MAX_ORDER+1);
bb(1:min(numel(b),TF_MAX_ORDER+1)) = b(1:min(numel(b),TF_MAX_ORDER+1));
aa(1:min(numel(a),TF_MAX_ORDER+1)) = a(1:min(numel(a),TF_MAX_ORDER+1));

if order < TF_MAX_ORDER
bb(order+2:end) = 0;
aa(order+2:end) = 0;
end

coeffs = single(zeros(25,1));
coeffs(1:11) = single(bb(:));
coeffs(12:22)= single(aa(:));
coeffs(23)   = single(order);
coeffs(24)   = single(N);
coeffs(25)   = single(FsHz);
end

function coeffs = make_ss25_3x3(A,B,C,D,L,K,Ki,N,FsHz)
A=single(A); B=single(B(:)); C=single(C(:)).'; D=single(D);
L=single(L(:)); K=single(K(:)); Ki=single(Ki);

assert(isequal(size(A),[3 3]), "A debe ser 3x3");
assert(numel(B)==3, "B debe tener 3");
assert(numel(C)==3, "C debe tener 3");
assert(numel(L)==3, "L debe tener 3");
assert(numel(K)==3, "K debe tener 3");

coeffs = single(zeros(25,1));

% Layout SS25:
%  1..9   A row-major
% 10..12  B
% 13..15  C
% 16      D
% 17..19  L
% 20..22  K
% 23      Ki
% 24      N
% 25      FsHz

coeffs(1:9)   = reshape(A.',9,1);
coeffs(10:12) = B(:);
coeffs(13:15) = C(:);
coeffs(16)    = D;
coeffs(17:19) = L(:);
coeffs(20:22) = K(:);
coeffs(23)    = Ki;
coeffs(24)    = single(N);
coeffs(25)    = single(FsHz);
end

% =========================
% Actions
% =========================
function onConnectToggle(~,~)
if ~S.isConnected
com = strtrim(string(edtCom.Value));
if com == "", logMsg("COM vacío."); return; end
try
S.sp = serialport(com, edtBaud.Value);
configureTerminator(S.sp, "LF");
S.sp.Timeout = 0.1;

flush(S.sp);
pause(0.05);
ll_flush();

S.isConnected = true;
btnConnect.Text = "Disconnect";
lblStat.Text = "CONNECTED: " + com;

stopStreaming();
S.streamParseEnabled = false;
S.streamRxBuf = uint8([]);

logMsg("Connected to " + com + " (NO timer; stream OFF until Start)");
startStreaming();

catch e
logMsg("Connect error: " + string(e.message));
S.isConnected = false;
S.sp = [];
end
else
try
stopStreaming();
if ~isempty(S.sp)
try flush(S.sp); catch, end
delete(S.sp);
end
catch
end
S.sp = [];
S.isConnected = false;
btnConnect.Text = "Connect";
lblStat.Text = "DISCONNECTED";
logMsg("Disconnected.");
end
end

function onReset(~,~)
if ~requireConn(); return; end
try
S.inTxn = true; clean = onCleanup(@setInTxnFalse); %#ok<NASGU>
stopStreaming();
ll_flush();
uartp_reset_local();
logMsg("reset OK (r)");
catch e
logMsg("reset FAIL: " + string(e.message));
end
startStreaming();
end

function onSendMode(~,~)
if ~requireConn(); return; end
try
S.inTxn = true; clean = onCleanup(@setInTxnFalse); %#ok<NASGU>
stopStreaming();
ll_flush();

mode = computeMode();
uartp_setmode_local(uint8(mode));

S.streamParseEnabled = false;
S.streamRxBuf = uint8([]);
logMsg(sprintf("setmode OK: mode=%d (%s) (stream OFF until Start)", mode, ddType.Value));
catch e
logMsg("setmode FAIL: " + string(e.message));
end
startStreaming();
end

function onSendCoeffs(~,~)
if ~requireConn(); return; end
typ = ddType.Value;

try
S.inTxn = true; clean = onCleanup(@setInTxnFalse); %#ok<NASGU>
stopStreaming();
ll_flush();

Nval = single(round(double(edtN.Value)));
FsHz = double(edtFs.Value);
if ~isfinite(FsHz) || FsHz <= 0, error("Fs inválida"); end

if strcmp(typ,'TF')
[b,a] = readTFTable();
ord = getTFOrder();
coeffs = make_tf25(b,a,ord,Nval,FsHz);

elseif strcmp(typ,'SS')
A = [ str2double(edtA11.Value) str2double(edtA12.Value) str2double(edtA13.Value);
str2double(edtA21.Value) str2double(edtA22.Value) str2double(edtA23.Value);
str2double(edtA31.Value) str2double(edtA32.Value) str2double(edtA33.Value) ];
B = [ str2double(edtB1.Value); str2double(edtB2.Value); str2double(edtB3.Value) ];
Cc= [ str2double(edtC1.Value) str2double(edtC2.Value) str2double(edtC3.Value) ];
D =  str2double(edtD.Value);
L = [ str2double(edtL1.Value); str2double(edtL2.Value); str2double(edtL3.Value) ];
K = [ str2double(edtK1.Value); str2double(edtK2.Value); str2double(edtK3.Value) ];
Ki=  str2double(edtKi.Value);

coeffs = make_ss25_3x3(A,B,Cc,D,L,K,Ki,Nval,FsHz);

else
coeffs = single(zeros(25,1));
coeffs(IDX_META_N)  = Nval;
coeffs(IDX_META_FS) = single(FsHz);
end

uartp_send_coeffs_local(coeffs, cbVerify.Value);

S.streamParseEnabled = false;
S.streamRxBuf = uint8([]);
logMsg("coeffs OK (" + typ + ") (25 floats). stream OFF until Start.");

catch e
logMsg("coeffs FAIL: " + string(e.message));
end

startStreaming();
end

function onGetCoeffs(~,~)
if ~requireConn(); return; end
try
S.inTxn = true; clean = onCleanup(@setInTxnFalse); %#ok<NASGU>
stopStreaming();
ll_flush();

rx_raw = uartp_get_coeffs_raw_local();   % 100 bytes
logBytes("t RAW (100B)", rx_raw);

c = typecast(uint8(rx_raw(:)).','single'); % 25 singles
c = c(:);

prettyPrintCoeffs25(c, "RX coeffs");

typ = ddType.Value;
if strcmp(typ,'TF')
b = double(c(1:11)).';
a = double(c(12:22)).';
ord = double(c(IDX_TF_ORDER));
N   = double(c(IDX_META_N));
Fs  = double(c(IDX_META_FS));

tfTable.Data = [b(:), a(:)];
edtTFOrder.Value = min(max(round(ord),0),TF_MAX_ORDER);

logMsg("t OK (TF25)");
logMsg(sprintf("order=%g  N=%g  Fs=%.6g", ord, N, Fs));
logMsg("b = [" + strjoin(string(b), " ") + "]");
logMsg("a = [" + strjoin(string(a), " ") + "]");
else
N  = double(c(IDX_META_N));
Fs = double(c(IDX_META_FS));
logMsg("t OK (25)");
logMsg(sprintf("meta: N=%g Fs=%.6g", N, Fs));
end

catch e
logMsg("t FAIL: " + string(e.message));
end
startStreaming();
end

function onStart(~,~)
if ~requireConn(); return; end
try
S.inTxn = true; clean = onCleanup(@setInTxnFalse); %#ok<NASGU>
stopStreaming();
ll_flush();

r_ui   = double(edtU0.Value);
r_mult = double(edtRmult.Value); if ~isfinite(r_mult), r_mult = 1; end
r_send = r_ui * r_mult;

uartp_init_local(r_send);

S.autoStopEnabled = logical(cbAutoStop.Value);
tgt = round(double(edtAutoStopN.Value));
if ~isfinite(tgt) || tgt < 0, tgt = 0; end
S.autoStopTarget = tgt;
S.autoStopStartBase = S.framesTotal;
S.autoStopPending = false;
S.autoStopReason = "";
S.autoStopArmed = (S.autoStopEnabled && S.autoStopTarget > 0);

S.streamParseEnabled = true;
S.streamRxBuf = uint8([]);
logMsg(sprintf("init OK: r_sent=%.6g (stream ON)", r_send));

catch e
logMsg("init FAIL: " + string(e.message));
S.streamParseEnabled = false;
end
startStreaming();
end

function onStop(~,~)
if ~requireConn(); return; end
try
S.inTxn = true; clean = onCleanup(@setInTxnFalse); %#ok<NASGU>

S.autoStopPending = false;
S.autoStopArmed = false;

S.streamParseEnabled = false;
stopStreaming();
ll_flush();

uartp_stop_local();

S.streamRxBuf = uint8([]);
logMsg("stop OK (s). stream OFF.");
catch e
logMsg("stop FAIL: " + string(e.message));
end
startStreaming();
end

function onExportMAT(~,~)
try
if isempty(S.nVec), uialert(fig,"No hay datos.","Export"); return; end
[file,path] = uiputfile("*.mat","Guardar datos",".\psoc_stream.mat");
if isequal(file,0), logMsg("Export cancelado."); return; end
data = struct();
data.n = S.nVec; data.u = S.uVec; data.y = S.yVec;
data.timestamp = datestr(now,'yyyy-mm-dd HH:MM:SS.FFF');
save(fullfile(path,file), "-struct", "data");
logMsg("Export OK: " + string(fullfile(path,file)));
catch e
logMsg("Export FAIL: " + string(e.message));
end
end

function onClearData(~,~)
S.nVec=zeros(0,1); S.uVec=zeros(0,1); S.yVec=zeros(0,1);
S.streamRxBuf=uint8([]); S.framesTotal=0;
applyPlotScaling(); updateDataInfo();
logMsg("Data cleared.");
end

% =========================
% Streaming
% =========================
function startStreaming()
stopStreaming();
if ~S.isConnected || isempty(S.sp), return; end

S.streamTimer = timer('ExecutionMode','fixedSpacing','Period',0.02, ...
'TimerFcn',@onStreamTick,'BusyMode','drop');
start(S.streamTimer);

if S.streamParseEnabled
logMsg("Streaming reader ON (parsing ENABLED) (frames 8B: u,y)");
else
logMsg("Streaming reader ON (parsing DISABLED) (discarding UART bytes)");
end
end

function stopStreaming()
try
if ~isempty(S.streamTimer) && isvalid(S.streamTimer)
stop(S.streamTimer); delete(S.streamTimer);
end
catch
end
S.streamTimer = [];
end

function onStreamTick(~,~)
if S.inTxn, return; end
if ~S.isConnected || isempty(S.sp), return; end

try
if S.autoStopPending
S.autoStopPending = false;
onStop();
return;
end

if ~S.streamParseEnabled
return;
end

nAvail = S.sp.NumBytesAvailable;
if nAvail <= 0, return; end

raw = read(S.sp, nAvail, "uint8");
if isempty(raw), return; end

S.streamRxBuf = [S.streamRxBuf; uint8(raw(:))];

n = numel(S.streamRxBuf);
nFrames = floor(n/8);
if nFrames <= 0, return; end

take = 8*nFrames;
blk = S.streamRxBuf(1:take);
S.streamRxBuf = S.streamRxBuf(take+1:end);

frames = reshape(blk, 8, []).';

u_u32 = uint32(frames(:,1)) ...
+ bitshift(uint32(frames(:,2)),8) ...
+ bitshift(uint32(frames(:,3)),16) ...
+ bitshift(uint32(frames(:,4)),24);

y_u32 = uint32(frames(:,5)) ...
+ bitshift(uint32(frames(:,6)),8) ...
+ bitshift(uint32(frames(:,7)),16) ...
+ bitshift(uint32(frames(:,8)),24);

u = typecast(u_u32,'single');
y = typecast(y_u32,'single');

idx0 = S.framesTotal;
nIdx = (idx0 + (1:numel(u))).';

S.nVec = [S.nVec; nIdx];
S.uVec = [S.uVec; double(u)];
S.yVec = [S.yVec; double(y)];

if numel(S.nVec) > S.maxPoints
k0 = numel(S.nVec)-S.maxPoints+1;
S.nVec = S.nVec(k0:end);
S.uVec = S.uVec(k0:end);
S.yVec = S.yVec(k0:end);
end

S.framesTotal = S.framesTotal + numel(u);

applyPlotScaling();
updateDataInfo();

if S.autoStopArmed
framesSinceStart = S.framesTotal - S.autoStopStartBase;
if framesSinceStart >= S.autoStopTarget
S.autoStopArmed = false;
S.autoStopPending = true;
S.autoStopReason = sprintf("framesSinceStart=%d >= %d", framesSinceStart, S.autoStopTarget);
logMsg("Auto-stop TRIGGER: " + S.autoStopReason);
end
end

drawnow limitrate;

catch e
S.streamRxBuf = uint8([]);
logMsg("stream WARN: " + string(e.message));
end
end

function onClose(~,~)
try
stopStreaming();
if S.isConnected && ~isempty(S.sp)
try flush(S.sp); catch, end
try delete(S.sp); catch, end
end
catch
end
delete(fig);
end

% =========================
% Debug helpers
% =========================
function s = hexDump(u8, maxLen)
if nargin<2, maxLen = 64; end
u8 = uint8(u8(:));
n = numel(u8);
m = min(n, maxLen);
hh = upper(string(dec2hex(u8(1:m),2)));
s = strjoin(hh.', ' ');
if n > m
s = s + " ... (+" + string(n-m) + " bytes)";
end
end

function logBytes(tag, u8)
if ~DBG_LOG_BYTES, return; end
if isempty(u8), logMsg(tag + ": <empty>"); return; end
u8 = uint8(u8(:));
if DBG_HEX_DUMP
logMsg(tag + " [" + string(numel(u8)) + "B] HEX: " + hexDump(u8, 80));
else
logMsg(tag + " [" + string(numel(u8)) + "B]");
end
end

function prettyPrintCoeffs25(c, label)
if nargin<2, label="coeffs"; end
if ~DBG_PRINT_COEFFS, return; end
c = double(c(:));
logMsg(label + " (25 floats):");
M = reshape(c, 5, 5).';
for r=1:5
line = sprintf("[%2d..%2d]  % .7g  % .7g  % .7g  % .7g  % .7g", ...
(r-1)*5+1, (r-1)*5+5, M(r,1), M(r,2), M(r,3), M(r,4), M(r,5));
logMsg(line);
end
end

end

\end{lstlisting}
