\section{Diagrama del Sistema}
La \textbf{Figura~\ref{fig:DiagramaControl}} muestra el diagrama de bloques del sistema de control de altura en lazo cerrado. La referencia de altura \(z_{\text{ref}}\) es comparada con la señal de salida medida \(z(t)\), generando el error \(e(t)\), el cual es procesado por el controlador.

El controlador representa el algoritmo de control implementado, pudiendo corresponder a un controlador estudiado en el semestre. A partir del error, el controlador genera la señal de control \(u(t)\), que constituye el esfuerzo aplicado al sistema.

La señal \(u(t)\) actúa sobre el actuador, conformado por el motor brushless y la hélice, el cual convierte la señal de control en empuje mecánico. Dicho empuje excita la planta física, cuya dinámica vertical determina la altura real del sistema \(y(t)\).

La altura es medida mediante un sensor TFMini Plus, que proporciona la señal \(z(t)\) utilizada para cerrar el lazo de control. En el diagrama se indican explícitamente las fuentes de ruido asociadas tanto al controlador como al sensor, reflejando las perturbaciones y no idealidades presentes en el sistema real.

\insertarfigura{img/Planta/Diagrama.jpg}{Diagrama de bloques de Control.}{fig:DiagramaControl}{1}

La \textbf{Figura~\ref{fig:Diagrama2}} muestra un diagrama de bloques que representa la implementación física y funcional completa del sistema de control de altura. En dicho diagrama se identifican claramente los siguientes subsistemas:
\begin{itemize}
	\item la cadena de energía (\texttt{batería} $\rightarrow$ \texttt{ESC} $\rightarrow$ \texttt{motor}),
	\item la cadena de control (\texttt{MATLAB} $\rightarrow$ \texttt{PSoC} $\rightarrow$ \texttt{PWM}),
	\item la planta física correspondiente al sistema bajo control,
	\item y la cadena de medición y realimentación (\texttt{planta} $\rightarrow$ \texttt{sensor} $\rightarrow$ \texttt{PSoC} $\rightarrow$ \texttt{MATLAB}).
\end{itemize}



\insertarfigura{img/Planta/Diagrama-Page-2.jpg}{Diagrama de bloques, implementación física.}{fig:Diagrama2}{1}

\subsection{Flujo de energía (parte electro--energética)}

La batería utilizada es una LiPo de tres celdas (3S), con tensión nominal de \(11{,}1\,\text{V}\). 
Cada celda presenta una tensión máxima de \(4{,}2\,\text{V}\), por lo que la batería completamente cargada alcanza:

\[
V_{\text{max}} = 12{,}6\,\text{V}
\]

Con el objetivo de preservar la integridad química de la batería y evitar degradación prematura, el rango operativo se restringe aproximadamente a:

\[
V \in [11{,}5,\; 12{,}5]\,\text{V}
\]

Evitar descargas por debajo de \(11{,}5\,\text{V}\) resulta fundamental, ya que tensiones inferiores pueden producir daño irreversible en las celdas LiPo.

La batería alimenta directamente al controlador electrónico de velocidad (ESC) de \(40\,\text{A}\), el cual convierte la tensión continua en señales trifásicas moduladas para accionar el motor brushless. 

El ESC incorpora disipadores térmicos integrados sobre los dispositivos de potencia (MOSFETs), cuya función es evacuar el calor generado durante la conmutación y conducción de corriente. Dado que el sistema opera en un régimen de potencia relativamente elevado para el tamaño del conjunto, la gestión térmica resulta crítica para evitar sobrecalentamientos que puedan producir fallas o reducción de eficiencia.

La presencia de disipadores mejora la transferencia térmica hacia el ambiente, aumentando la confiabilidad del sistema durante los intervalos de operación de aproximadamente \(5\,\text{min}\) continuos.

A medida que la batería se descarga, se observa una disminución progresiva de la tensión disponible, lo que impacta directamente en la capacidad de generación de empuje del motor. Este fenómeno es perceptible incluso en aplicaciones aeronáuticas (como drones), donde la pérdida de tensión se traduce en menor capacidad de sustentación.

En la práctica experimental, el tiempo de operación continua es del orden de \(5\,\text{min}\) como máximo. Esto se debe a que la batería utilizada posee una capacidad limitada para el nivel de potencia demandado por el sistema. 

El tiempo típico de recarga completa es aproximadamente \(1{,}5\,\text{h}\), lo que introduce una restricción significativa en la repetibilidad de los ensayos experimentales, constituyendo un factor limitante en el desarrollo de la práctica.

En esta etapa del sistema no se realiza acción de control propiamente dicha, sino únicamente conversión y transferencia de potencia hacia el actuador.

% ============================================================
\section{Arquitectura completa de implementación y flujo de operación}
\label{sec:arquitectura_total}
% ============================================================

En esta sección se describe la arquitectura completa del sistema de control implementado, integrando:

\begin{itemize}
	\item Interfaz MATLAB (\texttt{psoc\_control\_gui\_hl\_v3()})
	\item Protocolo de comunicación UARTP
	\item Firmware embebido en PSoC (\texttt{control\_app.c})
	\item Autocalibración automática del punto de hover
	\item Ejecución del controlador (TF y espacio de estados)
	\item Transmisión de telemetría en tiempo real
\end{itemize}

El sistema fue concebido como una arquitectura integrada y modular: MATLAB actúa como entorno de diseño, configuración y supervisión, mientras que el PSoC ejecuta el control en tiempo real con temporización determinística.

% ============================================================
\subsection{Interfaz MATLAB}
% ============================================================
\insertarfigura{img/GUI.png}
{Interfaz gráfica desarrollada en MATLAB: \texttt{psoc\_control\_gui\_hl\_v3()}.}
{fig:gui_matlab}{1}

El programa utilizado para la interacción con la planta es:

\begin{center}
	\texttt{psoc\_control\_gui\_hl\_v3()}
\end{center}

La interfaz permite:

\begin{itemize}
	\item Cargar modelos discretos (TF o espacio de estados)
	\item Enviar coeficientes al PSoC
	\item Definir frecuencia de muestreo
	\item Ajustar referencia
	\item Iniciar y detener sesiones de control
	\item Visualizar en tiempo real $u(t)$ e $y(t)$
\end{itemize}

La GUI constituye el nexo entre el diseño teórico en MATLAB y la implementación embebida en la planta real.

El código correspondiente se presenta en el Anexo~\ref{ap:gui_matlab}.

% ============================================================
\subsection{Protocolo UARTP}
% ============================================================

Se desarrolló un protocolo serial propietario denominado UARTP con el objetivo de simplificar la implementación del firmware y garantizar robustez en la comunicación.

\paragraph{Carga de coeficientes}

Para simplificar el parsing en el microcontrolador, la transmisión de coeficientes se realiza siempre mediante un paquete fijo de:

\[
25 \text{ floats}
\]

independientemente del tipo de controlador.

\subsubsection*{Formato del paquete}

\textbf{Controlador en función de transferencia (TF):}

\begin{itemize}
	\item $b_0 \dots b_{10}$
	\item $a_0 \dots a_{10}$
	\item Orden efectivo (0–10)
	\item Divisor de streaming $N$
	\item Frecuencia de muestreo $F_s$
\end{itemize}

\textbf{Controlador en espacio de estados (siempre 3 estados):}

\begin{itemize}
	\item $A$ (3x3)
	\item $B$ (3x1)
	\item $C$ (1x3)
	\item $D$
	\item $L$ (ganancia del observador)
	\item $K$ (realimentación de estados)
	\item $K_x$ (integrador o referencia directa)
	\item $N$
	\item $F_s$
\end{itemize}

\paragraph{Comandos rápidos}

Para reducir latencia:

\begin{itemize}
	\item START → 1 byte
	\item STOP → 5 bytes
\end{itemize}

\paragraph{Streaming}

La telemetría enviada es:

\[
[u_k,\; y_k]
\]

El parámetro $N$ actúa como divisor de muestreo:

\[
F_{\text{stream}} = \frac{F_s}{N}
\]

Si el buffer UART se llena, las muestras se descartan para evitar interferir con la ejecución del control.

% ============================================================
\subsection{Autocalibración automática del punto de hover}
% ============================================================

Antes de iniciar el control en lazo cerrado se ejecuta una rutina automática para estimar el punto de equilibrio (hover).

\subsubsection*{Motivación}

El punto de equilibrio del sistema depende de:

\begin{itemize}
	\item Nivel de batería
	\item Temperatura
	\item Condiciones mecánicas
\end{itemize}

Por lo tanto, se estima en cada sesión de control.

\subsubsection*{Procedimiento}

\begin{enumerate}
	\item Se fija la frecuencia de muestreo en 1000 Hz.
	\item Se realiza un barrido creciente de PWM entre:
	
	\[
	u \in
	\begin{aligned}
		[\texttt{CONTROL\_CALIB\_START\_US},\\
		\texttt{CONTROL\_CALIB\_MAX\_US}]
	\end{aligned}
	\]
	
	
	\item Se detecta movimiento si:
	
	\[
	|\Delta y| \geq \texttt{CONTROL\_CALIB\_DY\_CM}
	\]
	
	durante un número mínimo de muestras consecutivas.
	
	\item Se fija el offset:
	
	\[
	u_0 = g\_u0\_offset\_us
	\]
	
	\item Se estabiliza el sistema.
	\item Se retorna PWM a mínimo.
\end{enumerate}

Posteriormente el control se realiza en coordenadas relativas:

\[
\Delta u = u - u_0
\]

Esto desacopla la dinámica alrededor del punto de operación.

% ============================================================
\subsection{Modelo del sensor TFMini}
% ============================================================

El sensor TFMini Plus fue configurado mediante su interfaz serial según el procedimiento indicado en el datasheet, incluyendo la selección de frecuencia de muestreo.

Se realizó una calibración empírica de segundo orden:

\[
y = A + B d + C d^2
\]

Los coeficientes fueron obtenidos mediante \texttt{polyfit} en MATLAB.

La medición final se limita al rango operativo:

\[
y \in [10\,\text{cm},\;130\,\text{cm}]
\]

% ============================================================
\subsection{Control en espacio de estados con integrador}
% ============================================================

Se implementa la estructura de Ogata (Ec. 6.19):

\[
v(k+1) = v(k) + e(k)
\]

\[
u(k) = K_1 v(k+1) - K_2 \hat{x}(k)
\]

donde:

\begin{itemize}
	\item $K_2$ corresponde a la realimentación de estados
	\item $K_1$ es la ganancia del integrador
\end{itemize}

Todo el control opera en coordenadas relativas.

% ============================================================
\subsection{Anti-windup implementado}
% ============================================================

Se implementó un esquema de \textit{conditional integration}:

\begin{itemize}
	\item Si no hay saturación → integrar normalmente.
	\item Si hay saturación:
	\begin{itemize}
		\item Integrar sólo si el error empuja hacia la desaturación.
		\item En caso contrario, congelar el integrador.
	\end{itemize}
\end{itemize}

Esto evita acumulación indebida del estado integral.

% ============================================================
\subsection{Observadores implementados}
% ============================================================

Se implementaron dos variantes con tres estados:

\paragraph{Predictor}

\[
\hat{x}_{k+1} = A\hat{x}_k + Bu_k + L(y_k - \hat{y}_k)
\]

\paragraph{Actual}

Corrección previa:

\[
\hat{x}_k = \hat{x}_k^- + L(y_k - \hat{y}_k^-)
\]

Predicción posterior:

\[
\hat{x}_{k+1}^- = A\hat{x}_k + Bu_k
\]

% ============================================================
\subsection{Flujo completo de operación}
% ============================================================

\begin{enumerate}
	\item Diseño del controlador en MATLAB.
	\item Envío de coeficientes vía UARTP.
	\item Configuración de frecuencia del TFMini.
	\item Ejecución de autocalibración de hover.
	\item Inicio de sesión de control.
	\item Ejecución del controlador en cada período de muestreo.
	\item Streaming en tiempo real.
	\item STOP suave y cierre de sesión.
\end{enumerate}

% ============================================================
\subsection{Referencias a anexos}
% ============================================================

\begin{itemize}
	\item GUI MATLAB: Anexo~\ref{ap:gui_matlab}
	\item Firmware PSoC: Anexo~\ref{ap:main}
	\item Protocolo UARTP: Anexo~\ref{ap:uartp_sw}
\end{itemize}




